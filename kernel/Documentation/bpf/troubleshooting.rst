====================
Troubleshooting eBPF
====================

This document should help end-users with troubleshooting their eBPF
programs.  With a primary focus on programs under kernels samples/bpf.

Memory ulimits
==============

The eBPF maps uses locked memory, which is default very low.
Your program likely need to increase resource limit ``RLIMIT_MEMLOCK``
see system call `setrlimit(2)`_.

The ``bpf_create_map`` call will return errno EPERM (Operation not
permitted) when the RLIMIT_MEMLOCK memory size limit is exceeded.

.. _setrlimit(2): http://man7.org/linux/man-pages/man2/setrlimit.2.html

ELF binary
==========

The binary containing the eBPF program, which got generated by the
LLVM compiler, is an normal ELF binary.  For samples/bpf/ this is the
file named xxx_kern.o.

It is possible to inspect this normal ELF file, with tools like ``readelf``. ::

 $ readelf -SW xdp_ddos01_blacklist_kern.o
 There are 8 section headers, starting at offset 0x398:

 Section Headers:
  [Nr] Name           Type       Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                NULL       0000000000000000 000000 000000 00      0   0  0
  [ 1] .strtab        STRTAB     0000000000000000 000320 000072 00      0   0  1
  [ 2] .text          PROGBITS   0000000000000000 000040 000000 00  AX  0   0  4
  [ 3] xdp_prog       PROGBITS   0000000000000000 000040 0001b8 00  AX  0   0  8
  [ 4] .relxdp_prog   REL        0000000000000000 000300 000020 10      7   3  8
  [ 5] maps           PROGBITS   0000000000000000 0001f8 000028 00  WA  0   0  4
  [ 6] license        PROGBITS   0000000000000000 000220 000004 00  WA  0   0  1
  [ 7] .symtab        SYMTAB     0000000000000000 000228 0000d8 18      1   5  8
 Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

From the above output some trivial information can be extracted.  This
is an XDP program, as the defined program section 3 starts with the
letters "xdp".  From the same line ([ 3]) the size column also show
the program size 0001b8 in hex, which is easily converted on the
cmdline to 440 bytes.  Do notice this size is not the JIT'ed program
size::

 $ echo $((0x0001b8))
 440

The loader code samples/bpf/bpf_load.c parses elf file, extract needed
program sections, uses the maps section and relocation section (here
.relxdp_prog type REL) to remap the BPF_PSEUDO_MAP_FD instruction to
point to the correct map (which gets created during parsing of the
maps section, via standard bpf-syscall bpf_create_map).

LLVM disassemble support
------------------------

.. TODO:: Document what LLVM version this "-S" option got added

In newer versions of LLVM, the tool ``llvm-objdump``, supports showing
section names, asm code and original C code, if compiled with ``-g``. ::

 llvm-objdump -S prog_kern.o

.. TODO:: What does the option -no-show-raw-insn do?

Until this section is improved, look at mailing list response:
https://www.spinics.net/lists/netdev/msg407045.html

Extracting eBPF-JIT code
========================

For debugging/seeing the generated JIT code, is it possible to change
this proc sysctl::

 sysctl net.core.bpf_jit_enable=2

The output looks like::

 flen=55 proglen=335 pass=4 image=ffffffffa0006820 from=xdp_ddos01_blac pid=13333
 JIT code: 00000000: 55 48 89 e5 48 81 ec 28 02 00 00 48 89 9d d8 fd
 JIT code: 00000010: ff ff 4c 89 ad e0 fd ff ff 4c 89 b5 e8 fd ff ff
 JIT code: 00000020: 4c 89 bd f0 fd ff ff 31 c0 48 89 85 f8 fd ff ff
 JIT code: 00000030: bb 02 00 00 00 48 8b 77 08 48 8b 7f 00 48 89 fa
 JIT code: 00000040: 48 83 c2 0e 48 39 f2 0f 87 e1 00 00 00 48 0f b6
 JIT code: 00000050: 4f 0c 48 0f b6 57 0d 48 c1 e2 08 48 09 ca 48 89
 JIT code: 00000060: d1 48 81 e1 ff 00 00 00 41 b8 06 00 00 00 49 39
 JIT code: 00000070: c8 0f 87 b7 00 00 00 48 81 fa 88 a8 00 00 74 0e
 JIT code: 00000080: b9 0e 00 00 00 48 81 fa 81 00 00 00 75 1a 48 89
 JIT code: 00000090: fa 48 83 c2 12 48 39 f2 0f 87 90 00 00 00 b9 12
 JIT code: 000000a0: 00 00 00 48 0f b7 57 10 bb 02 00 00 00 48 81 e2
 JIT code: 000000b0: ff ff 00 00 48 83 fa 08 75 49 48 01 cf 31 db 48
 JIT code: 000000c0: 89 fa 48 83 c2 14 48 39 f2 77 38 8b 7f 0c 89 7d
 JIT code: 000000d0: fc 48 89 ee 48 83 c6 fc 48 bf 00 9c 24 5f 07 88
 JIT code: 000000e0: ff ff e8 29 cd 13 e1 bb 02 00 00 00 48 83 f8 00
 JIT code: 000000f0: 74 11 48 8b 78 00 48 83 c7 01 48 89 78 00 bb 01
 JIT code: 00000100: 00 00 00 89 5d f8 48 89 ee 48 83 c6 f8 48 bf c0
 JIT code: 00000110: 76 12 13 04 88 ff ff e8 f4 cc 13 e1 48 83 f8 00
 JIT code: 00000120: 74 0c 48 8b 78 00 48 83 c7 01 48 89 78 00 48 89
 JIT code: 00000130: d8 48 8b 9d d8 fd ff ff 4c 8b ad e0 fd ff ff 4c
 JIT code: 00000140: 8b b5 e8 fd ff ff 4c 8b bd f0 fd ff ff c9 c3

The ``proglen`` is the len of opcode sequence generated and ``flen``
is the number of bpf insns. You can use tools/net/bpf_jit_disasm.c to
disassemble that output. bpf_jit_disasm -o will dump the related
opcodes as well.
